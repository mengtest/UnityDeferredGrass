/**
 * Basic tessellation using _TessEdgeFactor and _TessInsideFactor control parameters.
 * Note that this is "static" tessellation, and is useful for things like vegetation.
 *
 * To use, simply include this .cginc and set the following pragmas:
 *
 *    #pragma vertex VertTessMain
 *    #pragma hull HullMain
 *    #pragma domain DomainMain
 *    #pragma target 4.6
 *    
 *    #include "include/Tessellation.cginc"
 *
 * By default, expects a `_TessEdgeFactor` and `_TessInsideFactor` control property to be set.
 * Alternatively, can define the CALCULATE_TESS_EDGE_FACTOR and CALCULATE_TESS_INSIDE_FACTOR
 * macros to provide custom tessellation factor logic.
 *
 * For dynamic tessellation, such as used in terrain or variable size objects or objects
 * as they get nearer to the camera, see:
 *
 *     Catlike Coding: Tessellation (Edge Length, Edge Length in Screen Space)
 *     https://catlikecoding.com/unity/tutorials/advanced-rendering/tessellation/
 */

#ifndef VF_TESSELATION_INCLUDED
#define VF_TESSELATION_INCLUDED

#include "CommonStruct.cginc"

// ------------------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------------------

/**
 * This is the "vertex program" that is invoked by the Domain shader.
 * Can be overwritten by the calling shader by defining its own VERT_MAIN.
 * This is called for each vertex generated by the tessellation operation,
 * whereas VERT_TESS_MAIN is only executed for the original control points.
 */
#ifndef VERT_MAIN
VertOutput VertMain(VertInput input)
{
    VertOutput output;

    output.position = input.position;
    output.normal   = input.normal;
    output.tangent  = input.tangent;
    output.uv       = input.uv;
    output.tex1     = input.tex1;
    output.tex2     = input.tex2;
    output.tex3     = input.tex3;

    return output;
}
#define VERT_MAIN(i) VertMain(i)
#endif

/**
 * This is the "real" vertex shader called in the vs stage.
 * Typically just a pass-through as it will only be invoked for the control points.
 */
#ifndef VERT_TESS_MAIN
TessellationControlPoint VertTessMain(VertInput input)
{
    TessellationControlPoint output;

    output.position = input.position;
    output.normal   = input.normal;
    output.tangent  = input.tangent;
    output.uv       = input.uv;
    output.tex1     = input.tex1;
    output.tex2     = input.tex2;
    output.tex3     = input.tex3;

    return output;
}
#define VERT_TESS_MAIN
#endif

// -----------------------------------------------------------------------------------------
// Hull Shader
// -----------------------------------------------------------------------------------------

// Used by the PatchConstantFunction to get the tessellation factors.
// May be defined outside of this cginc in order to provide custom overrides.
#ifndef CALCULATE_TESS_EDGE_FACTOR
float _TessEdgeFactor;
float CalcTessEdgeFactor() { return _TessEdgeFactor; }
#define CALCULATE_TESS_EDGE_FACTOR CalcTessEdgeFactor()
#endif

// Used by the PatchConstantFunction to get the tessellation factors.
// May be defined outside of this cginc in order to provide custom overrides.
#ifndef CALCULATE_TESS_INSIDE_FACTOR
float _TessInsideFactor;
float CalcTessInsideFactor() { return _TessInsideFactor; }
#define CALCULATE_TESS_INSIDE_FACTOR CalcTessInsideFactor()
#endif

/**
 * Calculates the tessellation factors.
 */
TessellationFactors PatchConstantFunction(InputPatch<TessellationControlPoint, 3> patch)
{
    TessellationFactors factors;

    float edge = CALCULATE_TESS_EDGE_FACTOR;
    float inside = CALCULATE_TESS_INSIDE_FACTOR;

    factors.edge[0] = edge;
    factors.edge[1] = edge;
    factors.edge[2] = edge;
    factors.inside = inside;

    return factors;
}

/**
 * Hull Shader, which defines how the tessellation should occur.
 */
[UNITY_domain("tri")]
[UNITY_outputcontrolpoints(3)]
[UNITY_outputtopology("triangle_cw")]
[UNITY_partitioning("integer")]
[UNITY_patchconstantfunc("PatchConstantFunction")]
TessellationControlPoint HullMain(InputPatch<TessellationControlPoint, 3> patch, uint id : SV_OutputControlPointID)
{
    return patch[id];
}

// -----------------------------------------------------------------------------------------
// Domain Shader
// -----------------------------------------------------------------------------------------

// Used to interpolate the different input variables across the new tessellated primitives.
#define DOMAIN_INTERPOLATION(field) data.field = (patch[0].field * coordinates.x) + (patch[1].field * coordinates.y) + (patch[2].field * coordinates.z)

/**
 * Domain Shader, which interpolates the original input variables across the tessellated primitive
 * and invokes the Vertex Shader for each new vertex.
 */
[UNITY_domain("tri")]
VertOutput DomainMain(TessellationFactors factors, OutputPatch<TessellationControlPoint, 3> patch, float3 coordinates : SV_DomainLocation)
{
    TessellationControlPoint data;

    DOMAIN_INTERPOLATION(position);
    DOMAIN_INTERPOLATION(normal);
    DOMAIN_INTERPOLATION(tangent);
    DOMAIN_INTERPOLATION(uv);

    return VERT_MAIN(data);
}

#endif